- name: init
  hosts: all
  gather_facts: no
  any_errors_fatal: yes
  tasks:
    - name: import check Ansible version task
      import_tasks: utils/assert-ansible-version.yaml

    - name: check that ansible_limit is defined
      assert:
        that: ansible_limit is defined
        fail_msg: Please explicitly limit the hosts you want to target with --limit
        quiet: yes
      # This prevents "ERROR! 'ansible_limit' is undefined" later.

    - name: check that this playbook is run against two hosts
      assert:
        that: ansible_play_hosts | length == 2
        fail_msg: You must limit this playbook to two hosts.
        quiet: yes
      run_once: yes

    - name: check that ansible_limit contains exactly one comma
      assert:
        that: ansible_limit is match('^[^,]+,[^,]+$')
        fail_msg: Please use the --limit option with one comma.
        quiet: yes

    - name: set source and destination host name
      set_fact:
        src_host: "{{ ansible_limit | regex_replace('(.+),.+', '\\1') }}"
        dest_host: "{{ ansible_limit | regex_replace('.+,(.+)', '\\1') }}"

- name: confirm
  hosts: all
  run_once: yes
  any_errors_fatal: yes
  gather_facts: no
  vars_prompt:
    - name: confirmation
      #     prompt: Are you sure you want to replace the DB of  "{{ dest_host }}" ...
      # Oh crap. "'dest_host' is undefined"
      prompt: >-
        Are you sure you want to replace the DB of
        "{{ ansible_limit | regex_replace('.+,(.+)', '\1') }}"
        ({{ lookup('env', 'PWD') | dirname | basename }}) [y/N]?
      private: no   # Show input (this is made to input passwords)
  tasks:
    - name: check confirmation
      assert:
        that: confirmation | lower == 'y'
        fail_msg: Confirmation failed.
        quiet: yes
  tags: molecule-notest


- name: export direct DB
  hosts: all
  any_errors_fatal: yes   # Doesn't do what I wanted with two hosts though...
  tasks:
    - name: backup DB on source host only
      block:
        - name: get source DB configuration
          include_role:
            name: get-db-config

        - name: backup
          include_role:
            name: db
            tasks_from: backup

      when: inventory_hostname == src_host

    - name: transfer the dump
      include_role:
        name: transfer-file
      vars:
        src_transfer_path: ~/db_dumps/{{ dump_name }}

    - name: import the dump on destination host only
      block:
        # FIXME: refactor to a role
        - name: get destination DB configuration
          include_role:
            name: get-db-config

        - name: check if DB exists
          include_role:
            name: db
            tasks_from: check-existence

        - name: create a backup before importing
          include_role:
            name: db
            tasks_from: backup
          when: db_exists.stdout == '1'
          # Note: it's "local_dump" instead of "dump_name" to avoid overriding the variable inside this role.

        - name: create database
          postgresql_db:
            name: "{{ db_conf.NAME }}"
            login_user: "{{ db_conf.USER | default(ansible_user, true) }}"
            login_password: "{{ db_conf.PASSWORD }}"
            login_host: "{{ db_conf.HOST }}"
            login_port: "{{ (db_conf.PORT | int) if db_conf.PORT else omit }}"
            state: present
          when: db_exists.stdout != '1'

        - name: import the dump
          block:
            - name: run pg_restore
              command:
                argv:
                  - pg_restore
                  - --dbname={{ db_conf.NAME }}
                  - --username={{ db_conf.USER }}
                  - --host={{ db_conf.HOST }}
                  - --port={{ db_conf.PORT }}
                  - --clean
                  - --if-exists
                  - --no-owner
                  - --no-acl
                  - --jobs=2
                  - "{{ dest_transfer_path }}"
              environment:
                PGPASSWORD: "{{ db_conf.PASSWORD }}"
              register: pg_restore_result
          rescue:
            - name: Skip version printing
              fail:
                msg: Failed (see above)
              when: >
                src_host == '__local__'
                  or 'could not open input file' in (pg_restore_result.stderr | default(''))

            - name: get source version
              command: pg_dump -V
              delegate_to: "{{ src_host }}"
              changed_when: false
              register: src_version

            - name: get destination version
              command: pg_restore -V
              changed_when: false
              register: dest_version

            - name: fail, printing versions
              fail:
                msg: |
                  pg_restore failed {{ warning_hint }}(see above)

                  FYI, source has "{{ src_version.stdout }}" and destination has "{{ dest_version.stdout }}"
              vars:
                warning_hint: >-
                  {{
                    '(or maybe it just finished with warnings) '
                    if ('WARNING:' in (pg_restore_result.stderr | default('')))
                    else ''
                  }}

      always:
        - name: remove temporary dump
          file:
            path: "{{ dest_transfer_path }}"
            state: absent

      when: inventory_hostname == dest_host
